#!/usr/bin/bash
set -euo pipefail
shopt -s expand_aliases

alias tool='podman run --rm \
        -v /dev:/dev -v `pwd`:/data \
        -w /data quay.io/jianzzha/toolset'

alias coreos-installer='podman run --privileged --pull always --rm \
        -v /dev:/dev -v /run/udev:/run/udev -v `pwd`:/data \
        -w /data quay.io/coreos/coreos-installer:release'

function setup_baremetal_interface() {
    systemctl enable NetworkManager --now
    mtu=`cat /sys/class/net/${BM_IF}/mtu`
    nmcli con down baremetal 2>/dev/null || true
    nmcli con del baremetal 2>/dev/null || true
    nmcli con add type bridge ifname baremetal con-name baremetal ipv4.method manual ipv4.addr 192.168.222.1/24 ipv4.dns 192.168.222.1 ipv4.dns-priority 10 autoconnect yes bridge.stp no
    nmcli con modify baremetal 802-3-ethernet.mtu ${DOLLAR}((mtu-4))
    nmcli con reload baremetal
    nmcli con up baremetal
    if [[ -n "${BM_IF}" && "${BM_IF}" != "null" ]]; then
        if [[ -n "${BM_VLAN}" && "${BM_VLAN}" != "null" ]]; then
            nmcli con down $BM_IF.$BM_VLAN 2>/dev/null || true
            nmcli con del $BM_IF.$BM_VLAN 2>/dev/null || true
            nmcli con add type vlan autoconnect yes con-name $BM_IF.$BM_VLAN ifname $BM_IF.$BM_VLAN dev $BM_IF id $BM_VLAN master baremetal slave-type bridge
            nmcli con reload $BM_IF.$BM_VLAN
            nmcli con up $BM_IF.$BM_VLAN
        else
            nmcli con down $BM_IF || true
            nmcli con del $BM_IF || true
            nmcli con add type bridge-slave autoconnect yes con-name $BM_IF ifname $BM_IF master baremetal
            nmcli con reload $BM_IF
            nmcli con up $BM_IF
        fi
    else
        echo "baremetal_phy_int not specified!"
        exit 1
    fi
}

function cleanup_baremetal_interface() {
    if [[ -n "${BM_VLAN}" && "${BM_VLAN}" != "null" ]]; then
        nmcli con down $BM_IF.$BM_VLAN 2>/dev/null || true
        nmcli con del $BM_IF.$BM_VLAN 2>/dev/null || true
    elif [[ "${BM_IF}" != "${default_route_interface}" ]]; then
        nmcli con down $BM_IF || true
        nmcli con del $BM_IF || true
    fi
    nmcli con down baremetal 2>/dev/null || true
    nmcli con del baremetal 2>/dev/null || true
}

function setup_firewall() {
    if firewall-cmd --state 2>/dev/null; then
        firewall-cmd --permanent --add-service=dhcp --add-service=dns || true
        firewall-cmd --permanent --add-port=${http_port}/tcp || true
    fi
}

function set_iptable_service() {
    cleanup_iptable_service
    /bin/cp -f ocp-iptables.sh /usr/local/bin/ocp-iptables.sh
    chmod u+x /usr/local/bin/ocp-iptables.sh
    /bin/cp -f ocp-iptables.service /usr/local/lib/systemd/system/ocp-iptables.service
    iptables -t nat -A POSTROUTING -s 192.168.222.0/24 ! -d 192.168.222.0/24 -o ${default_route_interface} -j MASQUERADE
}

function cleanup_iptable_service() {
    /bin/rm -rf /usr/local/lib/systemd/system/ocp-iptables.service || true
    /bin/rm -rf /usr/local/bin/ocp-iptables.sh || true
    while iptables -C POSTROUTING -t nat -s 192.168.222.0/24 ! -d 192.168.222.0/24 \
                   -o ${default_route_interface} -j MASQUERADE 2>/dev/null; do 
        iptables -D POSTROUTING -t nat -s 192.168.222.0/24 ! -d 192.168.222.0/24 -o ${default_route_interface} -j MASQUERADE
    done
}
        
function remove_dnsmasq() {
    if podman container exists ocp-dnsmasq; then
        podman rm -f ocp-dnsmasq
    fi
}

function setup_dnsmasq() {
    remove_dnsmasq
    podman run -dit --name ocp-dnsmasq -v `pwd`/dnsmasq:/etc/dnsmasq.d --cap-add=NET_ADMIN --cap-add=NET_ADMIN \
        --net=host quay.io/jianzzha/dnsmasq -d -q --conf-file=/etc/dnsmasq.d/dnsmasq.conf \
        --enable-tftp --tftp-root=/var/lib/tftpboot --log-queries --log-dhcp
}

function remove_httpd() {
    if podman container exists ocp-httpd; then
        podman rm -f ocp-httpd
    fi
}

function setup_httpd() {
    remove_httpd
    podman run -dit --name ocp-httpd -p ${http_port}:80 -v `pwd`/htdocs:/usr/local/apache2/htdocs/ docker.io/httpd:2.4
}

function install_openshift_installer() {
    mkdir -p tmp
    if [[ -f tmp/openshift-install-linux.tar.gz ]]; then
        expected_checksum=`curl -sS ${client_base_url}/${client_version}/sha256sum.txt | grep -e openshift-install-linux-${client_version}.tar.gz | cut -d ' ' -f 1`
        if echo "${DOLLAR}{expected_checksum} tmp/openshift-install-linux.tar.gz" | sha256sum --check --status; then
            return
        fi
    fi
    curl -L -o tmp/openshift-install-linux.tar.gz ${client_base_url}/${client_version}/openshift-install-linux.tar.gz
    /bin/rm -rf /usr/local/bin/openshift-install
    tar -C /usr/local/bin -xzf tmp/openshift-install-linux.tar.gz
}

function install_openshift_client() {
    mkdir -p tmp
    if [[ -f tmp/openshift-client-linux.tar.gz ]]; then
        expected_checksum=`curl -sS ${client_base_url}/${client_version}/sha256sum.txt | grep -e openshift-client-linux-${client_version}.tar.gz | cut -d ' ' -f 1`
        if echo "${DOLLAR}{expected_checksum} tmp/openshift-client-linux.tar.gz" | sha256sum --check --status; then
            return
        fi
    fi
    curl -L -o tmp/openshift-client-linux.tar.gz ${client_base_url}/${client_version}/openshift-client-linux.tar.gz
    /bin/rm -rf /usr/local/bin/{kubectl,oc}
    tar -C /usr/local/bin -xzf tmp/openshift-client-linux.tar.gz
}

function download_rhcos_iso() {
    mkdir -p tmp
    if [[ -f tmp/rhcos-live.x86_64.iso ]]; then
        expected_checksum=`curl -sS ${rcos_iso_url}/sha256sum.txt | grep rhcos-live.x86_64.iso | cut -d ' ' -f 1`
        if echo "${DOLLAR}{expected_checksum} tmp/rhcos-live.x86_64.iso" | sha256sum --check --status; then
            return
        fi
    fi
    curl -L -o tmp/rhcos-live.x86_64.iso "${rcos_iso_url}/rhcos-live.x86_64.iso"
}

function setup_http_contents() {
    download_rhcos_iso
    /bin/rm -rf htdocs/rhcos-live.x86_64.iso 2>/dev/null || true
    coreos-installer iso ignition embed -i ocp/bootstrap-in-place-for-live-iso.ign tmp/rhcos-live.x86_64.iso -o htdocs/rhcos-live.x86_64.iso
    # The following is for kernel parameter POC
    if [[ "${kargs_poc}" == "true" ]]; then
        /bin/cp -f ocp/bootstrap-in-place-for-live-iso.ign htdocs/
        rm -rf htdocs/{rhcos-live.x86_64-initrd.img,rhcos-live.x86_64-rootfs.img,rhcos-live.x86_64-vmlinuz}
        rm -rf tmp/{rhcos-live.x86_64-initrd.img,rhcos-live.x86_64-rootfs.img,rhcos-live.x86_64-vmlinuz}
        pushd tmp
        coreos-installer iso extract pxe rhcos-live.x86_64.iso
        popd
        /bin/mv tmp/{rhcos-live.x86_64-initrd.img,rhcos-live.x86_64-rootfs.img,rhcos-live.x86_64-vmlinuz} htdocs/
    fi
    chmod 0644 htdocs/*
}

function update_etc_hosts() {
    # first remove all duplicate host entries
    cleanup_etc_hosts
    cat hosts >> /etc/hosts
}

function cleanup_etc_hosts() {
    # first remove all duplicate host entries
    while read -r line; do
        name=`echo ${DOLLAR}line | awk '{print ${DOLLAR}2}'`
        sed -i "/${DOLLAR}name/d" /etc/hosts
    done < hosts
}

function start_pxe_boot() {
    tool ipmitool -I lanplus -H ${ipmi_addr} -U ${ipmi_user} -P ${ipmi_password} chassis bootdev pxe ${pxe_opt}
    tool ipmitool -I lanplus -H ${ipmi_addr} -U ${ipmi_user} -P ${ipmi_password} chassis power cycle
}

# if containers are still up, to re-deploy sno, "pxe" command will do
if [[ ${1:-""} == "pxe" ]]; then
    start_pxe_boot
    exit 0
elif [[ ${1:-""} == "start-containers" ]]; then
# after host reboots, all containers are down, use "start-containers" to bring them backup
    setup_dnsmasq
    setup_httpd
    exit 0
elif [[ ${1:-""} == "clean" ]]; then
# command "clean" means remove containers and delete baremetal network
    remove_httpd
    remove_dnsmasq
    cleanup_baremetal_interface
    cleanup_iptable_service
    exit 0
elif [[ ${1:-""} == "setup-iptables" ]]; then
# command "setup-iptables" will re-establish the iptable entry
    set_iptable_service
    exit 0
elif [[ ${1:-""} == "add-hosts" ]]; then
# command "add-hosts" will add entries to /etc/hosts
    update_etc_hosts
    exit 0
elif [[ ${1:-""} == "remove-hosts" ]]; then
# command "remove-hosts" will remove entries from /etc/hosts
    cleanup_etc_hosts
    exit 0
elif [[ ${1:-""} == "no-pxe" ]]; then
# command "no-pxe" will prepare everything except pxe boot
    no_pxe="true"
elif [[ ${1:-""} == "help" ]]; then
# command "help" is self explaining
    echo "Without a sub-command, $0 will install SNO from scratch"
    echo "Available sub-commands:"
    echo "    pxe: pxe boot the taget host" 
    echo "    clean: clean up the network and service containers"
    echo "    start-containers: re-start the service containers"
    echo "    setup-iptables: reset the iptable entry added by this script"
    echo "    add-hosts: add SNO dns entries to /etc/hosts"
    echo "    remove-hosts: delete SNO dns entries from /etc/hosts"
    echo "    no-pxe: prepare everything except pxe boot"
    exit 0
elif [[ ${1:-""} != "" ]]; then
    echo "invalid sub-command!"
    exit 1
fi

# without a sub-command means install from scratch
setup_baremetal_interface
setup_firewall
set_iptable_service
install_openshift_installer
install_openshift_client
update_etc_hosts
openshift-install --dir=ocp create single-node-ignition-config
setup_dnsmasq
setup_httpd
setup_http_contents
if [[ ${DOLLAR}{no_pxe:-"false"} == "true" ]]; then
    exit 0
fi
start_pxe_boot
openshift-install --dir=ocp wait-for install-complete

